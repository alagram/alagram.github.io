<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: TDD | Albert Agram]]></title>
  <link href="http://alagram.github.io/blog/categories/tdd/atom.xml" rel="self"/>
  <link href="http://alagram.github.io/"/>
  <updated>2014-09-09T08:38:09+00:00</updated>
  <id>http://alagram.github.io/</id>
  <author>
    <name><![CDATA[Albert Agram]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Simple Test using TDD with Rspec]]></title>
    <link href="http://alagram.github.io/blog/2014/09/05/simple-test-using-tdd-with-rspec/"/>
    <updated>2014-09-05T19:12:00+00:00</updated>
    <id>http://alagram.github.io/blog/2014/09/05/simple-test-using-tdd-with-rspec</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>Introduction</h2>

<p>Test Driven Development is great for driving out implementation of features in software development. In this post, I&rsquo;m going to go through how I write tests using the TDD approach with <a href="https://github.com/rspec/rspec-rails">Rspec</a> by going through the steps to drive out the implementation of simple search feature. We&rsquo;ll implement a method named <code>search_by_title</code>.</p>

<h2>How I Write Tests</h2>

<p>  1) I start by thinking about all the test cases I want to cover. That is, thinking on a high level on what the functionality should achieve. This allows me to have more complete coverage of what I want my code to accomplish instead of diving straight into one test, making it pass and then figuring out what the next test should be.</p>

<p>  2) Setup data for tests, perform action and put an assertion on the result of the action.</p>

<p>  3) Run test and let it fail.</p>

<p>  4) Finally, take small steps to make the test pass. This is because in TDD you want to write the simplest code to make a test pass and also make sure that every piece of code you write is going to be the result of a failing test.</p>

<h3>The code</h3>

<p>By following step 1, I write out all the test cases I want to cover:</p>

<p>```ruby
require &ldquo;rails_helper&rdquo;</p>

<p>RSpec.describe Video, :type => :model do
  it { should belong_to :category }
  it { should validate_presence_of :title }
  it { should validate_presence_of :description }</p>

<p>  describe &ldquo;search_by_title&rdquo; do</p>

<pre><code>it "returns an empty array if there is no match"
it "returns an array of one video for an exact match"
it "returns an array of one video for a partial match"
it "returns an array of all matches ordered by created_at"
it "returns an empty array for a search with an empty string"
</code></pre>

<p>  end
end
```</p>

<p>The video model in <code>app/models/video.rb</code> looks like this:</p>

<p><code>ruby
class Video &lt; ActiveRecord::Base
  belongs_to :category
  validates_presence_of :title, :description
end
</code></p>

<p>Next, I&rsquo;ll set up the data I need for the first test, perform an action and make an assertion on the result; step 2. The code for the first test looks like this:</p>

<p><code>ruby
it "returns an empty array if there is no match" do
  futurama = Video.create(title: "Futurama", description: "Space Travel!")
  back_to_future = Video.create(title: "Back to Future", description: "Time Travel")
  expect(Video.search_by_title("hello")).to eq([])
end
</code></p>

<p>Now I&rsquo;ll run the test and let it fail; step 3:</p>

<p><code>bash
rspec spec/models/video_spec.rb
</code></p>

<p><img src="/images/2014-09-05-simle-test-using-tdd-with-rspec/spec_1.png" title="Spec 1" ></p>

<p>Test is complaining about <code>NoMethodError: undefined method search_by_title for #&lt;Class:0x007f9ec0ad0d98&gt;</code></p>

<p>Next, make that little change in <code>app/models/video.rb</code>; step 4:</p>

<p>```ruby
class Video &lt; ActiveRecord::Base
  belongs_to :category</p>

<p>  validates_presence_of :title, :description</p>

<p>  def self.search_by_title
  end
end
```</p>

<p>Run test again:</p>

<p><code>bash
rspec spec/models/video_spec.rb
</code></p>

<p><img src="/images/2014-09-05-simle-test-using-tdd-with-rspec/spec_2.png" title="Spec 2" ></p>

<p>This time the failure is <code>ArgumentError: wrong number of arguments (1 for 0)</code>. In our test, we pass a parameter to the method and have to replicate that in the real code.</p>

<p>Let&rsquo;s make that change:</p>

<p>```ruby
class Video &lt; ActiveRecord::Base</p>

<p>  &hellip;</p>

<p>  def self.search_by_title(search_term)
  end
end
```</p>

<p>Run the test again:</p>

<p><code>bash
rspec spec/models/video_spec.rb
</code></p>

<p><img src="/images/2014-09-05-simle-test-using-tdd-with-rspec/spec_3.png" title="Spec 3" ></p>

<p>There is another error:</p>

<p><code>bash
expected: []
got: nil
</code></p>

<p>The easiest change to make the test pass is to return an empty array in the <code>search_by_title</code> method:</p>

<p>```ruby
class Video &lt; ActiveRecord::Base</p>

<p>  &hellip;</p>

<p>  def self.search_by_title(search_term)</p>

<pre><code>[]
</code></pre>

<p>  end
end
```</p>

<p>At this point, if all all method does is to return an empty array this is all we need to satisfy that.</p>

<p>Now when we run the test again, we&rsquo;ll have a passing test:</p>

<p><img src="/images/2014-09-05-simle-test-using-tdd-with-rspec/spec_4.png" title="Spec 4" ></p>

<p>Fortunately, we have other test cases that we do want to satisfy and by following this simple process for each test, we&rsquo;re forced to drive-out the actually implementation of the method:</p>

<p>Our final code in <code>app/models/video.rb</code> will look like this:</p>

<p>```ruby
class Video &lt; ActiveRecord::Base
  belongs_to :category</p>

<p>  validates_presence_of :title, :description</p>

<p>  def self.search_by_title(search_term)</p>

<pre><code>return [] if search_term.blank?
where("title LIKE ?", "%#{search_term}%").order("created_at DESC")
</code></pre>

<p>  end
end
```</p>

<p>And our test code will be:</p>

<p>```ruby
require &ldquo;rails_helper&rdquo;</p>

<p>RSpec.describe Video, :type => :model do
  it { should belong_to :category }
  it { should validate_presence_of :title }
  it { should validate_presence_of :description }</p>

<p>  describe &ldquo;search_by_title&rdquo; do</p>

<pre><code>it "returns an empty array if there is no match" do
  futurama = Video.create(title: "Futurama", description: "Space Travel!")
  back_to_future = Video.create(title: "Back to Future", description: "Time Travel")
  expect(Video.search_by_title("hello")).to eq([])
end

it "returns an array of one video for an exact match" do
  futurama = Video.create(title: "Futurama", description: "Space Travel!")
  back_to_future = Video.create(title: "Back to Future", description: "Time Travel")
  expect(Video.search_by_title("Futurama")).to eq([futurama])
end

it "returns an array of one video for a partial match" do
  futurama = Video.create(title: "Futurama", description: "Space Travel!")
  back_to_future = Video.create(title: "Back to Future", description: "Time Travel")
  expect(Video.search_by_title("urama")).to eq([futurama])
end

it "returns an array of all matches ordered by created_at" do
  futurama = Video.create(title: "Futurama", description: "Space Travel!", created_at: 1.day.ago)
  back_to_future = Video.create(title: "Back to Future", description: "Time Travel")
  expect(Video.search_by_title("Futur")).to eq([back_to_future, futurama])
end

it "returns an empty array for a search with an empty string" do
  futurama = Video.create(title: "Futurama", description: "Space Travel!", created_at: 1.day.ago)
  back_to_future = Video.create(title: "Back to Future", description: "Time Travel")
  expect(Video.search_by_title("")).to eq([])
end
</code></pre>

<p>  end
end
```</p>

<p>And all our tests pass:</p>

<p><img src="/images/2014-09-05-simle-test-using-tdd-with-rspec/spec_pass.png" title="Spec Pass" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Types of Testing and shoulda-matchers]]></title>
    <link href="http://alagram.github.io/blog/2014/08/31/types-of-testing-and-shoulda-matchers/"/>
    <updated>2014-08-31T11:11:00+00:00</updated>
    <id>http://alagram.github.io/blog/2014/08/31/types-of-testing-and-shoulda-matchers</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>Introduction</h2>

<p>When developing software, how do you know something works? Its certain that all software have bugs and the only way to make sure the code you&rsquo;ve written is bug-free is by designing test cases to test against your codebase. It is the most objective way to say confidently that a feature works and things did not break. This post looks at types of testing and how to use <a href="https://github.com/thoughtbot/shoulda-matchers">shoulda-matchers</a> to test common Rails functionality.</p>

<h3>Types of testing</h3>

<p>1) <em><strong>Unit Tests</strong></em>: Unit tests involve testing different components in isolation. You&rsquo;ll typically focus on one block at a time and make sure all cases are covered. In the Rails context, unit testing includes tests for models, views, helpers and routes in isolation. In sum, you&rsquo;re focusing on one thing at a time. Unit tests are the fastest in terms of speed and offer the best coverage.</p>

<p>2) <em><strong>Functional Tests</strong></em>: Functional tests involve testing multiple components together. This is another way of making sure different parts of a system work in tandem. In the Rails context, functional testing includes controller tests. Typically the controller is where you pull multiple models and make them work with eachother to generate data before passing them over to the views. You&rsquo;ll also be testing request and response cycles.</p>

<p>3) <em><strong>Integration Tests</strong></em>: This involves following a business process to make sure that not only do components work together, but can also work together to achieve a business objective. Integration testing involves mimicking the end-user by driving through the browser. You can login, fill a form, submit forms, click links and buttons etc. Integration tests are more realistic because you&rsquo;re following what a user of your system would do.</p>

<h3>shoulda-matcher</h3>

<p>In Test Driven Development (TDD) you&rsquo;ll typically want to test your own code. <a href="https://github.com/thoughtbot/shoulda-matchers">shoulda-matchers</a> is a library that simplifies testing common Rails functionality like associations and validations. Suppose we have a <code>video</code> model with the following code:</p>

<p>```ruby</p>

<h1>video.rb</h1>

<p>class Video &lt; ActiveRecord::Base
  belongs_to :category</p>

<p>  validates_presence_of :title, :description
end
```</p>

<p>using <code>shoulda-matchers</code> we can write a few lines of code to test the functionality of our code:</p>

<p><code>ruby
it { should belong_to :category }
it { should validate_presence_of :title }
it { should validate_presence_of :description }
</code></p>

<p>These simple lines can take the place of all the following tests:</p>

<p>```ruby
it &ldquo;belongs to a category&rdquo; do
  cat = Category.create(name: &ldquo;Action&rdquo;)
  vid = Video.create(title: &ldquo;Yet another fake video&rdquo;, description: &ldquo;Not sure&hellip;&rdquo;, category: cat)
  expect(vid.category).to eq(cat)
end</p>

<p>it &ldquo;does not save video without a title&rdquo; do
  video = Video.create(description: &ldquo;I like this movie&rdquo;)
  expect(Video.count).to eq(0)
end</p>

<p>it &ldquo;does not save a video without a description&rdquo; do
  video = Video.create(title: &ldquo;Robocop&rdquo;)
  expect(Video.count).to eq(0)
end
```</p>
]]></content>
  </entry>
  
</feed>
