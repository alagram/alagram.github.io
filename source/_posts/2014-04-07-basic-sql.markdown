---
layout: post
title: "Basic SQL"
date: 2014-04-07 11:35
comments: true
categories: SQL
---

<!-- more -->
Introduction
-------------------

In this blog post, we want to introduce you to SQL and Databases. We want to make sur you understand what's happening behind the scenes before diving in the [ORM](http://en.wikipedia.org/wiki/Object-relational_mapping) world with Rails. We'll start by explaining the key concepts of databases. Later, we'll introduce you to some basic SQL commands and syntax while buiding a database of our favourite books.



<!-- In this blog post, we'll look at basic SQL concepts while building a database of our favorite books. The best way to learn is by practicing the commands in a real relational database. We'll make use of MySQL, however, any relational database product will also work. -->


<!-- ####1.0) An Introduction to SQL and Explaining Tables -->

####1) Bird's eye view of Databases

Lets suppose we have to store the name, address and age of a few hundred people. We could easily start by opening up a text file and inputting our values. The advantage is this is very easy to setup and use. And although the first ten to twenty will look great, overtime you'll find that we'll have typos and duplicate data. Also, we have to manually keep track of every single dataset. Further, we'll also have to query our data for information purposes. At this point you'll realise that we have a huge problem. We need a better way to organize our data.

This is where relational databases come into play. Relational databases offer a general-purpose solution for organizing data with mimimum redundancy.

A database is a collection of organized data. It is worth explaining that `relational` here doesn't mean relationships. Relational here has a mathematical [basis](http://en.wikipedia.org/wiki/Relational_model). When used in connection with databases, it means a system where we can store data in a tabular fashion.

Structured Query Language or `SQL` is the standard language used for  communicating with relational databases. Software which is used to manage digital databases is called a Database Management System (DBMS).

What follows is an explanation of the core concepts of Databases.


##### What is a Table?

To help you properly accept the concept of databases, we're going to use spreadsheets as an analogy. To optimize the use of spreadsheets, we usually create a file or a workbook with multiple sheets. If you want to store data in a spreadsheet you'll have to make use of rows and columns.

Suppose we have two sheets inside our workbook that keep track of users and reviews respectively:

{% img center /images/users.png 400 400 'users' 'images' %}

{% img center /images/reviews.png 400 400 'reviews' 'images' %}

Our first sheet has 3 columns that help us keep track of a user's `id`, `username` and `email`. The second sheet has two columns: `id` and `content`. Lets call these sheets `users` and `reviews`.

Technically, in relational databases, a table is an organized set of data elements where columns describe the type of data and rows contain the actual data to be stored. A sheet is a perfect analogy of a table within a database.

##### Rows and Columns

A relational database has columns and rows. A row represents a single set of related data whiles a column provides a standardized way of storing data in the rows of a database. For instance, in our `users` sheet, the `username` column is set up to contain only the username value of a particular user. We cannot store a integer in this column. Also, the first row contains data related to john.

##### Relational Database Views

The two main views are data and schema views. The dataview displays with columns at the top and rows of data for each dataset, just like an Excel spreadsheet. It shows the data in a table. A schema view shows the column names and column type.


{% img center /images/schema_view.png 600 500 'schema view' 'images' %}


##### Interacting with a database

Relational database interfaces are in two forms, GUI and command line. It is important to note that they all the same. Making a choice between these two is a matter of preference.


##### Primary Key and Foreign Key

There is a unique column to keep track of each row of data. This column is called primary key. Most relational databases default this to the `id` column. Rails use's this default as well.

Foreign key helps is link information from one table to another. The foreign key column will contain the primary key of another table. Lets suppose we want to link our `users` and `reviews` tables to keep track of who a review belongs to. We could create a `review_username` column to store the user's `username` in our `reviews` table. But the problem with this approach is the `username` column is not unique. There could be multiple Sam's in the `users` table. We need a unique column and the perfect candidate is the `id` column. `user_id` will become our foreign key created in the `reviews` table.


{% img center /images/foreign_key.png 400 400 'foreign key' 'images' %}


Now the first review belongs to alice, the second belongs to john and the last review belongs to sam.


With these basic concepts out of the way, we'll get our hands dirty with some basic SQL syntax in the next section.

####2) SQL Fundamentals


___Note on being hands-on:__ Like all crafts, you need hands-on practice to gain experience. That's the approach the rest of this tutorial takes. We want you to actually write the codes and follow along. If you read through this tutorial without writing any code, it is likely you will understand the theories. But you will not actually be able to do it. We believe the best way to learn is by doing these tasks. So buckle up and lets go!_

#####Getting started

For the sake of simplicity we'll use [SQLite3](https://sqlite.org/). If you're on Mac OSX you can install `SQLite3` using [Homebrew](http://brew.sh/) by running `brew install sqlite3`. Windows users can download and install `SQLite3` [here](http://www.sqlite.org/download.html). See [here](http://www.thegeekstuff.com/2011/07/install-sqlite3/) for Linux installation instructions.

##### Data Definition Language

SQL has basics verbs. You can think of them as different ways to talk to a database. They are:

- Data Manipulation Language: INSERT, UPDATE, DELETE
- Data Query Language: SELECT
- Data Control Language: GRANT, REVOKE etc.
- Transaction Control Commands: COMMIT, ROLLBACK ect.

##### SQL Data types
Just like the Ruby language has data types like `Array`, `Hash` etc, SQL also has its special data-types. The common ones are:

- Variable length characters    (`varchar`)
- Integer values             (`int`)
- Decimal numbers            (`decimal`)
- Date data type             (`date`)

##### Creating a Database
Its time to get our feet wet vy creating our first database. Databases serve as a holding envelop for tables. If you recall from our earlier analogy, its like a spreadsheet. We'll create a database named `library` from the command line:

Example:

{% codeblock lang:sql %}
sqlite3 library.db
{% endcodeblock %}

##### Table Creation
Next, we'll create a `books_tbl` table.

{% codeblock lang:sql %}
  CREATE TABLE books_tbl (id INTEGER, title VARCHAR(20), author VARCHAR(15));
{% endcodeblock %}

##### Inserting data

We're all set now; lets populate our table with some data. To polupate data we use the `INSERT` command

{% codeblock lang:sql %}
INSERT INTO books_tbl VALUES (1, 'The Famous 5', 'Enid Blyton');
INSERT INTO books_tbl VALUES (2, 'Sweet Valley',  'Francine Pascal');
{% endcodeblock %}

####3. Working with Constraints

So far, we've created a table and populated it with data, but we have some problems to deal with. We want our table to hold meaningful information about our books. In that regard, it would make sense to create our table in such a way that certain fields do not accept empty or `NULL` values. This is where constraints come in.

Contstraints are rules to abide by while doing SQL operations. Constraints help make data in your database more useful and structured. For instance, every book must have a title, author and year. Below we create a table that accepts `NULL` constraints in some fields.

{% codeblock lang:sql %}
  CREATE TABLE books_tbl_cp (id INTEGER NOT NULL, title VARCHAR(20) NOT NULL, author VARCHAR(25) NOT NULL, published INTEGER NOT NULL, publisher VARCHAR(15) NULL);
{% endcodeblock %}

What we've done is to ensure that only `publisher` field will accept empty or `NULL` values. Let's populate this table.

{% codeblock lang:sql %}
INSERT INTO books_tbl_cp VALUES (1, 'The Famous 5', 'Enid Blyton', 1942, NULL);
INSERT INTO books_tbl_cp VALUES (2, 'Sweet Valley', 'Francine Pascal', 1983, 'Random House');
{% endcodeblock %}

Now when we try to insert data into an column with a constraint set to `NOT NULL`, we'll see an error. Try it:

{% codeblock lang:sql %}
INSERT INTO books_tbl_cp VALUES (NULL, 'Some Book', 'Our favorite writer', 2001, 'Random House');

Error: books_tbl_cp.id may not be NULL
{% endcodeblock %}


##### Primary Key Constraint
We've solved one problem, but we're faced with yet another. We have to ensure that none of the records would duplicate information about the same book. Let's demostrate we can actually do this with code that insert a duplicate `id`:

{% codeblock lang:sql %}
INSERT INTO books_tbl_cp VALUES (1, 'Yet Another Awesome Book', 'John Doe', 2014, 'Random House');
{% endcodeblock %}


A primary key is used to ensure uniqueness of data. It's also used to identify a row of data in a table, is almost always a number value and does not allow `NULL` values. Also, a table can only have one primary key. ID fields are generally used as primary keys.

To deonstrate, lets create a new table `fav_books_tbl` with a `primary key` set to the `id` field. Also, we'd like to have our `primary key` auto incremented without specifying a value.


{% codeblock lang:sql %}
  CREATE TABLE fav_books_tbl (
   id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
   title VARCHAR(60) NOT NULL,
   published INTEGER NOT NULL,
   publisher VARCHAR(50) NULL
  );
{% endcodeblock %}

Now, we do not have to specify the `id` value as it'll be tracked and auto-incremented by our database:

{% codeblock lang:sql %}
INSERT INTO fav_books_tbl (title, published, publisher) VALUES ('The Famous 5', 1942, NULL);
INSERT INTO fav_books_tbl (title, published, publisher) VALUES ('Sweet Valley', 1983, 'Random House');
{% endcodeblock %}

Also, when we try to insert duplicate `id` fields, our databse will complain. Try it:

{% codeblock lang:sql %}
INSERT INTO fav_books_tbl VALUES (1, 'Sweet Valley', 1983, 'NULL');

Error: PRIMARY KEY must be unique
{% endcodeblock %}

We have learned about Primary Keys and why they're necessary. Also, we've seen a different way of inserting data into a table. Next, we'll look at Unique Key Constraint.


##### Unique Key Constraint
Let's things up a notch by exploring the concept of a unique key. A unique key, like the primary key is used to ensure uniqueness of data. Unique key, makes sure that data is not duplicated in two rows in the database. There are subtle differences between the two. For example, a table can have more than one unique key. A field with a unique key can take only one NULL value.

In our case, we can now decide to make `title` field unique. This would ensure that there are no duplicate titles in our table. This time we'll only modify the column.


{% codeblock lang:sql %}
ALTER TABLE fav_books_tbl MODIFY COLUMN title VARCHAR(60) NOT NULL UNIQUE;
{% endcodeblock %}

Now our `fav_books_tbl` table ensures the `title` column does not have duplicate records. Give it a shot:

{% codeblock lang:sql %}
INSERT INTO fav_books_tbl (title, published, publisher) VALUES ('The Famous 5', 1942, NULL);
{% endcodeblock %}


####4) Operations on Tables
Lets clean up our database by learning a few Table Operations.

##### Dropping Tables

We drop tables in SQL with the `DROP TABLE` command. Lets go ahead and drop a few tables.

{% codeblock lang:sql %}
DROP TABLE books_tbl;
DROP TABLE books_tbl_cp;
{% endcodeblock %}


####5) Simple SQL Queries

Before moving on to more interesting querying, lets insert some data into our table.

{% codeblock lang:sql %}
INSERT INTO fav_books_tbl (title, published, publisher) VALUES ('Twelve Years A Slave', 1853, 'Derby & Miller, Auburn, New York');
INSERT INTO fav_books_tbl (title, published, publisher) VALUES ('David and Goliath', 2013, 'Little, Brown and Company');
INSERT INTO fav_books_tbl (title, published, publisher) VALUES ('The Power of Habit', 2012, 'Random House');
INSERT INTO fav_books_tbl (title, published, publisher) VALUES ('Tales of The East', 2001, 'Unknown');
{% endcodeblock %}

Also, lets create a table `authors` and add some data to it:

{% codeblock lang:sql %}
CREATE TABLE authors (
   id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
   name VARCHAR(100) NOT NULL
  );

INSERT INTO authors (name) VALUES ('Solomon Northup');
INSERT INTO authors (name) VALUES ('Charles Duhigg');
INSERT INTO authors (name) VALUES ('Malcolm Gladwell');
INSERT INTO authors (name) VALUES ('Enid Blyton');
INSERT INTO authors (name) VALUES ('Francine Pascal');

{% endcodeblock %}


##### Selecting all records from a table

{% codeblock lang:sql %}
SELECT * FROM fav_books_tbl;
{% endcodeblock %}

This query will return all rows in `fav_books_tbl` table.

##### Selecting a limited number of columns

{% codeblock lang:sql %}
SELECT title, author FROM fav_books_tbl;
{% endcodeblock %}



##### Ordering results
Suppose we want to order results from a query, say, by title and  published date.

{% codeblock lang:sql %}
SELECT title, published FROM fav_books_tbl ORDER BY published;
{% endcodeblock %}


Next lets further sort by descending and ascending respectively.

{% codeblock lang:sql %}
SELECT title, published FROM fav_books_tbl ORDER BY published DESC;
{% endcodeblock %}


{% codeblock lang:sql %}
SELECT title, published FROM fav_books_tbl ORDER BY published ASC;
{% endcodeblock %}


We could order a query with an abbreviation instead of the column name.

{% codeblock lang:sql %}
SELECT title, published FROM fav_books_tbl ORDER BY 2 ASC;
{% endcodeblock %}

Abbreviations start from 1 which is given to the first column we specify et cetera. So we've succeeded in reproducing our previous query, with the 2 in place of `published`.


##### WHERE clause

The `WHERE` command gives us the ability to specify condtions in our query. If the condition is not met, no result will be returned form the database. The `WHERE` clause usually has two parts, `SELECT` and the `FROM` clause. We can query for all books with that were published in 2012:

{% codeblock lang:sql %}
SELECT * FROM fav_books_tbl WHERE published = 2012;
{% endcodeblock %}

We can use other operators as `<, >, <=` and also construct completx conditions with `AND` and `OR` boolean operators:

{% codeblock lang:sql %}
SELECT title, published FROM fav_books_tbl WHERE published > 1980 AND publisher IS NOT NULL;
{% endcodeblock %}

Here we select title and published columns from our `fav_books_tbl` table where `published` date is greated that 1980 and pusblisher is not empty.

##### Updating Data
The `UPDATE` command gives us to abily to update existing records. The record mush exist in the databse for the `UPDATE` to take effect. Here is an example where we update the publisher for The Famous 5:

{% codeblock lang:sql %}
UPDATE fav_books_tbl SET publisher = 'Hodder & Stoughton' WHERE id = 1;
{% endcodeblock %}


##### Deleting Data

You guessed correct, you can use the `DELETE` command to delete records form a table. We'll always want to use a `WHERE` clause in conjuction with `DELETE` unless we want to delete all records form the table.

Let's delete the unknown publisher from `fav_books_tbl`:

{% codeblock lang:sql %}
DELETE FROM fav_books_tbl WHERE publisher = 'Unknown';
{% endcodeblock %}

We'll turn our attention to databse association's next.


####4) One To One / One To Many Association

In designing our `fav_books_tbl` table we could have easily added an `author` column. But this tends to complicate data modeling and should be avoided. `author` is an entity by itself and so should be a seperate table. We'll use the Foreign Key concept to demonstrate One To One / One To Many relationships. Now suppose we want to join our `fav_books_tbl` and `authors` tables, in our case we'll create a foreign key `author_id` in our `fav_books_tbl` table:

{% codeblock lang:sql %}
ALTER TABLE fav_books_tbl ADD COLUMN author_id INTEGER;
{% endcodeblock %}

We'll want to populate our `author_id` column but before that let's display the data in our `fav_books_tbl` and `authors` tables

{% codeblock lang:sql %}
SELECT * FROM fav_books_tbl;
SELECT * FROM authors;
{% endcodeblock %}


The Famous 5 has an `id` of 1 in our `fav_books_tbl` table; we know it's auhtor is Enid Blyton, with an `id` of 4 in our `authors` table. We can complete the association with this code:

{% codeblock lang:sql %}
UPDATE fav_books_tbl SET author_id = 4 WHERE ID = 1;
{% endcodeblock %}

What this is saying update the `fav_books_tbl` table with `author_id` equal to 4 where `id` is 1.

Lets update all the other `author_id` fields in our table:
{% codeblock lang:sql %}
UPDATE fav_books_tbl SET author_id = 5 WHERE ID = 2;
UPDATE fav_books_tbl SET author_id = 1 WHERE ID = 3;
UPDATE fav_books_tbl SET author_id = 3 WHERE ID = 4;
UPDATE fav_books_tbl SET author_id = 2 WHERE ID = 5;
{% endcodeblock %}


####5) Join Table

Next we need to connect our `fav_books_tbl` and `authors` to have a bidirectional relationship.
